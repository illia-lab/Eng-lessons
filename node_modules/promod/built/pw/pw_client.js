"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Browser = exports.browser = void 0;
const sat_utils_1 = require("sat-utils");
const selenium_webdriver_1 = require("selenium-webdriver");
const execute_script_1 = require("../helpers/execute.script");
const mappers_1 = require("../mappers");
const internals_1 = require("../internals");
function validateBrowserCallMethod(browserClass) {
    const protKeys = Object.getOwnPropertyNames(browserClass.prototype).filter((item) => item !== 'constructor');
    for (const key of protKeys) {
        const descriptor = Object.getOwnPropertyDescriptor(browserClass.prototype, key);
        if ((0, sat_utils_1.isAsyncFunction)(descriptor.value)) {
            const originalMethod = descriptor.value;
            // eslint-disable-next-line no-inner-declarations
            async function decoratedWithChecker(...args) {
                if (!this._engineDriver) {
                    throw new Error(`
${key}(): Seems like driver was not initialized, please check how or where did you call getDriver function
or visit https://github.com/Simple-Automation-Testing/promod/blob/master/docs/init.md#getDriver
					`);
                }
                return originalMethod.call(this, ...args);
            }
            Object.defineProperty(decoratedWithChecker, 'name', { value: key });
            descriptor.value = decoratedWithChecker;
            Object.defineProperty(browserClass.prototype, key, descriptor);
        }
    }
    return new browserClass();
}
class PageWrapper {
    constructor(context) {
        this._context = context;
        this._logs = [];
    }
    async updateContext(context) {
        this._context = context;
        const contextPages = await context.pages();
        if (contextPages.length) {
            this._currentPage = contextPages[0];
        }
        else {
            this._currentPage = await this._context.newPage();
        }
    }
    async getCurrentPage() {
        if (!this._currentPage) {
            const page = await this._context.newPage();
            this._currentPage = page;
            this._initialPage = page;
            this._initialPage.on('console', async (msg) => {
                for (const arg of msg.args()) {
                    const msfData = {
                        level: msg.type(),
                        type: msg.location(),
                        timestamp: Date.now(),
                        message: await arg.jsonValue(),
                    };
                    this._logs.push(msfData);
                }
            });
        }
        return this._currentPage;
    }
    async switchToNextPage(tabObject = {}) {
        const { strictEquality = true, index = 0, expectedQuantity, timeout = 5000 } = tabObject, titleUrl = __rest(tabObject, ["strictEquality", "index", "expectedQuantity", "timeout"]);
        if ((0, sat_utils_1.isNumber)(expectedQuantity)) {
            let errorMessage;
            await (0, sat_utils_1.waitForCondition)(async () => {
                const tabs = this._context.pages();
                errorMessage = () => `Expected browser tabs count is ${expectedQuantity}, current browser tabs count is ${tabs.length}`;
                return tabs.length === expectedQuantity;
            }, { message: errorMessage, timeout });
        }
        if ((0, sat_utils_1.isNumber)(index) && this._context.pages().length < index + 1) {
            throw new Error(`Index is out available browser tabs count, index is ${index}, current browser tabs count is ${this._context.pages().length}`);
        }
        else if ((0, sat_utils_1.isNumber)(index)) {
            this._currentPage = this._context.pages()[index];
        }
        if ((0, sat_utils_1.isNotEmptyObject)(titleUrl)) {
            let errorMessage;
            await (0, sat_utils_1.waitForCondition)(async () => {
                const tabs = this._context.pages();
                for (const tab of tabs) {
                    this._currentPage = tab;
                    const currentBrowserState = {
                        url: await this._currentPage.url(),
                        title: await this._currentPage.title(),
                    };
                    const { result } = (0, sat_utils_1.compareToPattern)(currentBrowserState, titleUrl, { stringIncludes: !strictEquality });
                    if (result)
                        return true;
                }
                errorMessage = () => `Expected browser tab state is ${(0, sat_utils_1.safeJSONstringify)(titleUrl)}, current browser tab states was not met`;
            }, { message: errorMessage, timeout });
        }
    }
}
class ContextWrapper {
    constructor(serverBrowser, config = {}) {
        this.server = serverBrowser;
        this._contextConfig = config;
    }
    async switchPage(data) {
        await this._currentPage.switchToNextPage(data);
    }
    getPageLogs() {
        return this._currentPage._logs;
    }
    async runNewContext(browserData = {}) {
        const { currentBrowserName, newBrowserName, capabilities } = browserData;
        const config = capabilities || this._contextConfig;
        const { userAgent, isMobile, viewport } = config;
        if ((0, sat_utils_1.isString)(currentBrowserName)) {
            this._currentContext['__promodBrowserName'] = currentBrowserName;
        }
        this._currentContext = await this.server.newContext({ userAgent, isMobile, viewport });
        if ((0, sat_utils_1.isString)(newBrowserName)) {
            this._currentContext['__promodBrowserName'] = newBrowserName;
        }
        if (!this._currentPage) {
            this._currentPage = new PageWrapper(this._currentContext);
        }
        else {
            await this._currentPage.updateContext(this._currentContext);
        }
        this._currentContext.on('page', async (page) => {
            // @ts-ignore
            this._currentContext._pages.add(page);
        });
    }
    async getCurrentContext() {
        if (!this._currentContext) {
            await this.runNewContext();
        }
        return this._currentContext;
    }
    // TODO implement with tab - page title
    async changeContext({ index, browserName }) {
        const contexts = await this.server.contexts();
        if ((0, sat_utils_1.isNumber)(index) && contexts[index]) {
            this._currentContext.removeListener('page', () => { });
            this._currentContext = contexts[index];
            this._currentContext.on('page', async (page) => {
                // @ts-ignore
                this._currentContext._pages.add(page);
            });
            await this._currentPage.updateContext(this._currentContext);
        }
        if (browserName && contexts.find((item) => item['__promodBrowserName'] === browserName)) {
            this._currentContext.removeListener('page', () => { });
            this._currentContext = contexts.find((item) => item['__promodBrowserName'] === browserName);
            this._currentContext.on('page', async (page) => {
                // @ts-ignore
                this._currentContext._pages.add(page);
            });
            await this._currentPage.updateContext(this._currentContext);
        }
    }
    async getCurrentPage() {
        await this.getCurrentContext();
        if (!this._currentPage) {
            this._currentPage = new PageWrapper(this._currentContext);
        }
        return this._currentPage.getCurrentPage();
    }
    async closeAllContexts() {
        if (this._currentContext) {
            await this._currentContext.close();
        }
        const contexts = await this.server.contexts();
        for (const context of contexts) {
            await context.close();
        }
    }
    async getContexts() {
        return await this.server.contexts();
    }
}
class Browser {
    constructor() {
        this.wait = sat_utils_1.waitForCondition;
        this.wait = sat_utils_1.waitForCondition;
    }
    static getBrowser() {
        return validateBrowserCallMethod(Browser);
    }
    currentClient() {
        return this._engineDriver;
    }
    injectEngine({ context, page }) {
        if (context) {
            const browser = context.browser();
            this._contextWrapper = new ContextWrapper(browser);
        }
        if (page) {
            const context = page.context();
            const browser = context.browser();
            this._contextWrapper = new ContextWrapper(browser);
        }
    }
    /** @private */
    async getWorkingContext() {
        if ((0, sat_utils_1.isAsyncFunction)(this._contextFrame)) {
            return await this._contextFrame();
        }
        return await this._contextWrapper.getCurrentPage();
    }
    /** @private */
    async getCurrentPage() {
        return await this._contextWrapper.getCurrentPage();
    }
    async setBasicAuth(authData, dontThrowOnError = true) {
        try {
            const page = await this.getCurrentPage();
            await page.setExtraHTTPHeaders({
                Authorization: `Basic ${Buffer.from(`${authData.username}:${authData.password}`).toString('base64')}`,
            });
        }
        catch (error) {
            if (dontThrowOnError) {
                console.error(error);
            }
            else {
                throw error;
            }
        }
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const currentPageScreenshot = await browser.getTabs();
     *
     * @returns {Promise<any[]>}
     */
    async getTabs() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "getTabs" from wrapped API`);
        return await (await this._contextWrapper.getCurrentContext()).pages();
    }
    async runNewBrowser(browserData = {}) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "runNewBrowser" from wrapped API, args: `, browserData.currentBrowserName, browserData.newBrowserName, browserData.capabilities);
        await this._contextWrapper.runNewContext(browserData);
    }
    async switchToBrowser(browserData = {}) {
        const { index, browserName } = browserData, tabData = __rest(browserData, ["index", "browserName"]);
        if ((0, sat_utils_1.isNumber)(index) && (await this._contextWrapper.getContexts()).length > index) {
            return await this._contextWrapper.changeContext({ index });
        }
        if ((0, sat_utils_1.isString)(browserName)) {
            return await this._contextWrapper.changeContext({ browserName });
        }
        if ((0, sat_utils_1.isNotEmptyObject)(tabData)) {
            for (const [index] of (await this._contextWrapper.getContexts()).entries()) {
                await this._contextWrapper.changeContext({ index });
                const result = await this.switchToBrowserTab(tabData)
                    .then(() => true, () => false)
                    .catch(() => false);
                if (result) {
                    return;
                }
            }
        }
        throw new Error(`switchToBrowser(): required browser was not found`);
    }
    setClient({ driver, server, config }) {
        this._engineDriver = driver;
        this._contextWrapper = new ContextWrapper(driver, config);
        this._server = server;
    }
    set setCreateNewDriver(driverCreator) {
        this._createNewDriver = driverCreator;
    }
    get keyboard() {
        return mappers_1.KeysPW;
    }
    get Key() {
        return selenium_webdriver_1.Key;
    }
    get baseUrl() {
        return this.appBaseUrl;
    }
    set baseUrl(url) {
        this.appBaseUrl = url;
    }
    async returnToInitialTab() {
        // there was no switching in test
        if (!this.initialTab) {
            return;
        }
        await this.closeAllpagesExceptInitial();
        // set initialTab to null for further "it" to use
        this.initialTab = null;
    }
    async closeAllpagesExceptInitial() { }
    /**
     *
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.openNewTab('https://www.npmjs.com/package/promod');
     *
     * @param {string} url url that needs to open in new browser tab
     * @return {Promise<void>}
     */
    async openNewTab(url = 'data:,') {
        return (await this._contextWrapper.getCurrentPage()).evaluate((openUrl) => {
            window.open(openUrl, '_blank');
        }, url);
    }
    /**
     *
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.switchToTab({ index: 2, expectedQuantity: 3 });
     *
     * @param {TSwitchBrowserTabPage} tabObject tab description
     * @return {Promise<void>}
     */
    async switchToTab(tabObject) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "switchToTab" from wrapped API, args: `, tabObject);
        if (!this.initialTab) {
            this.initialTab = await this.getCurrentTab();
        }
        await this.switchToBrowserTab(tabObject);
    }
    /**
     * @info https://github.com/microsoft/playwright/issues/10143
     *
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const tabTitles = [];
     * await browser.makeActionAtEveryTab(async () => {
     *    tabTitles.push(await browser.getTitle());
     * });
     *
     * @param {!Function} action action that needs to be performed
     * @return {Promise<void>}
     */
    async makeActionAtEveryTab(action, handles) {
        const tabsCount = await this.getTabsCount();
        await (0, sat_utils_1.asyncForEach)((0, sat_utils_1.lengthToIndexesArray)(tabsCount), async (index) => {
            await this.switchToBrowserTab({ index });
            await action();
        });
    }
    /**
     * @info https://github.com/microsoft/playwright/issues/10143
     *
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.setCookies({name: 'test', value: 'test'});
     * @param {TCookie | TCookie[]} cookies cookies object
     * @returns {Promise<void>}
     */
    async setCookies(cookies) {
        const currentUrl = await this.getCurrentUrl();
        const parsed = new URL(currentUrl);
        const cookiesToSet = (0, sat_utils_1.toArray)(cookies).map((_a) => {
            var { url = parsed.origin, domain, path } = _a, items = __rest(_a, ["url", "domain", "path"]);
            if (domain && path) {
                return Object.assign({ domain, path }, items);
            }
            return Object.assign({ url }, items);
        });
        await (await this._contextWrapper.getCurrentContext()).addCookies(cookiesToSet);
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const cookies = await browser.getCookies();
     * @return {Promise<Array<TCookie>>} cookies list
     */
    async getCookies() {
        return await (await this._contextWrapper.getCurrentContext()).cookies();
    }
    /**
     * @info https://github.com/microsoft/playwright/issues/10143
     *
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.deleteCookie('test');
     * @param {string} name cookie name
     * @returns {Promise<void>}
     */
    async deleteCookie(name) {
        const ctx = await this._contextWrapper.getCurrentContext();
        const filteredCookies = (await ctx.cookies()).filter((cookie) => cookie.name !== name);
        await ctx.clearCookies();
        await ctx.addCookies(filteredCookies);
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const cookie = await browser.getCookieByName('test');
     * @param {string} name cookie name
     * @return {Promise<{ name: string; value: string }>}
     */
    async getCookieByName(name) {
        const ctx = await this._contextWrapper.getCurrentContext();
        const requiredCookie = (await ctx.cookies()).find((cookie) => cookie.name === name);
        return requiredCookie;
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.deleteAllCookies();
     *
     * @return {Promise<void>}
     */
    async deleteAllCookies() {
        await (await this._contextWrapper.getCurrentContext()).clearCookies();
    }
    /**
     * switchToBrowserTab
     * @private
     */
    async switchToBrowserTab(tabObject) {
        await this._contextWrapper.switchPage(tabObject);
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const currentTabsCount = await browser.getTabsCount();
     *
     * @returns {Promise<number>}
     */
    async getTabsCount() {
        return (await this._contextWrapper.getCurrentContext()).pages().length;
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const currentPageUrl = await browser.getCurrentUrl();
     *
     * @return {Promise<string>}
     */
    async getCurrentUrl() {
        return (await this._contextWrapper.getCurrentPage()).url();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const currentPageScreenshot = await browser.takeScreenshot();
     *
     * @returns {Promise<Buffer>}
     */
    async takeScreenshot() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "takeScreenshot" from wrapped API`);
        return (await this._contextWrapper.getCurrentPage()).screenshot();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.maximize();
     *
     * @return {Promise<void>}
     */
    async maximize() {
        /**
         * @info it is workaround implementation for maximization of the browser page
         */
        const { width, height } = await (await this._contextWrapper.getCurrentPage()).evaluate(() => {
            const { availHeight, availWidth } = window.screen;
            return { width: availWidth, height: availHeight };
        });
        (await this._contextWrapper.getCurrentPage()).setViewportSize({ width, height });
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const browserLogs = await browser.getBrowserLogs();
     *
     * @return {Promise<TLogLevel[] | string>}
     */
    async getBrowserLogs() {
        try {
            return this._contextWrapper.getPageLogs();
        }
        catch (e) {
            return 'Comman was failed ' + e.toString();
        }
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.keyDownAndHold(browser.keyboard.PageDown)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async keyDownAndHold(key, element) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "keyDownAndHold" from wrapped API, args: `, key, element);
        if (element) {
            (await element.getEngineElement()).hover();
            await (await this.getCurrentPage()).keyboard.down(key);
        }
        else {
            await (await this.getCurrentPage()).keyboard.down(key);
        }
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.keyUp(browser.keyboard.PageDown)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async keyUp(key, element) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "keyUp" from wrapped API, args: `, key, element);
        if (element) {
            (await element.getEngineElement()).hover();
            return await (await this.getCurrentPage()).keyboard.up(key);
        }
        else {
            return await (await this.getCurrentPage()).keyboard.up(key);
        }
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.keyDownAndUp(browser.keyboard.PageDown)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async keyDownAndUp(key, element) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "keyUp" from wrapped API, args: `, key, element);
        if (element) {
            (await element.getEngineElement()).hover();
            await (await this.getCurrentPage()).keyboard.down(key);
            await (await this.getCurrentPage()).keyboard.up(key);
        }
        else {
            await (await this.getCurrentPage()).keyboard.down(key);
            await (await this.getCurrentPage()).keyboard.up(key);
        }
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * cosnt { height, width } = await browser.getWindomSize();
     *
     * @return {Promise<{ height: number; width: number }>} window size
     */
    async getWindomSize() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "getWindomSize" from wrapped API`);
        return await (await this._contextWrapper.getCurrentPage()).evaluate(() => ({ height: window.outerHeight, width: window.outerWidth }));
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * cosnt title = await browser.getTitle();
     *
     * @return {Promise<string>} tab (page) title
     */
    async getTitle() {
        return (await this._contextWrapper.getCurrentPage()).title();
    }
    async getCurrentTab() {
        return await this._contextWrapper.getCurrentPage();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.get('https://github.com/Simple-Automation-Testing/promod');
     *
     * @param {string} url url that needs to be open
     * @return {Promise<void>}
     */
    async get(url) {
        const getUrl = (0, mappers_1.resolveUrl)(url, this.appBaseUrl);
        (await this._contextWrapper.getCurrentPage()).goto(getUrl);
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.switchToIframe('my-iframe');
     *
     * @param {string} selector iframe selector
     * @param {boolean} [jumpToDefaultFirst] should switch to top frame first
     * @return {Promise<void>}
     */
    async switchToIframe(selector, jumpToDefaultFirst = false, { timeout = 30000, message = '' } = {}) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "switchToIframe" from wrapped API, args: `, selector, jumpToDefaultFirst);
        if (jumpToDefaultFirst) {
            await this.switchToDefauldIframe();
        }
        this._contextFrame = async () => {
            return await (0, sat_utils_1.waitForCondition)(async () => {
                const page = await this.getCurrentPage();
                const pageFrames = await page.frames();
                const frames = await (0, sat_utils_1.asyncFilter)(pageFrames, async (frame) => (await frame
                    .frameLocator(selector)
                    .first()
                    .locator('*')
                    .all()
                    .catch(() => [])).length > 0);
                for (const [_index, frame] of frames.entries()) {
                    const allElements = await frame
                        .frameLocator(selector)
                        .first()
                        .locator('*')
                        .all()
                        .catch(() => []);
                    const res = await (0, sat_utils_1.asyncSome)(allElements, async (item) => await item.isVisible());
                    if (res) {
                        return (await (await frame.frameLocator(selector).first().locator('*').first().elementHandle({ timeout: 25 })).ownerFrame());
                    }
                }
            }, {
                timeout,
                message: (t, e = 'without error') => `switchToIframe('${selector}'): required iframe was not found, timeout ${t}, error: ${e} ${message ? '\n' + message : ''} `,
            });
        };
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.switchToDefauldIframe();
     *
     * @return {Promise<void>}
     */
    async switchToDefauldIframe() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "switchToDefauldIframe" from wrapped API`);
        this._contextFrame = null;
        this._contextFrameHolder = null;
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.setWindowSize(800, 600);
     *
     * @param {number} width window width
     * @param {number} height window height
     * @return {Promise<void>}
     */
    async setWindowSize(width, height) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "setWindowSize" from wrapped API, args: `, width, height);
        (await this._contextWrapper.getCurrentPage()).setViewportSize({ width, height });
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.sleep(800);
     *
     * @param {number} time time in ms
     * @return {Promise<void>}
     */
    async sleep(time) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "sleep" from wrapped API, args: `, time);
        await (() => new Promise((resolve) => setTimeout(resolve, time)))();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * const result = await browser.executeScript(() => document.body.offsetHeight);
     *
     * @param {!Function} script scripts that needs to be executed
     * @param {any|any[]} [args] function args
     * @returns {Promise<any>}
     */
    async executeScript(script, args) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "executeScript" from wrapped API, args: `, script, args);
        const recomposedArgs = await (0, execute_script_1.toNativeEngineExecuteScriptArgs)(args);
        return await (await this.getWorkingContext()).evaluate(script, recomposedArgs);
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.back();
     *
     * @return {Promise<void>}
     */
    async back() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "back" from wrapped API`);
        (await this._contextWrapper.getCurrentPage()).goBack();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.forward();
     *
     * @return {Promise<void>}
     */
    async forward() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "forward" from wrapped API`);
        (await this._contextWrapper.getCurrentPage()).goForward();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.refresh();
     *
     * @return {Promise<void>}
     */
    async refresh() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "refresh" from wrapped API`);
        (await this._contextWrapper.getCurrentPage()).reload();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.quit();
     *
     * @return {Promise<void>}
     */
    async quit() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "quit" from wrapped API`);
        await (await this._contextWrapper.getCurrentContext()).close();
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.quitAll();
     *
     * @return {Promise<void>}
     */
    async quitAll() {
        await this._contextWrapper.closeAllContexts();
        await this._engineDriver.close();
        if (this._server) {
            await this._server.close();
        }
    }
    /**
     * @example
     * const { playwrightWD } = require('promod');
     * const { browser } = playwrightWD;
     *
     * await browser.close();
     *
     * @return {Promise<void>}
     */
    async close() {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "close" from wrapped API`);
        (await this.getCurrentPage()).close();
    }
    async scrollElementByMouseWheel(element, x, y, deltaX, deltaY, duration) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "scrollElementByMouseWheel" from wrapped API, args: `, element, x, y, deltaX, deltaY, duration);
        const { x: elementX, y: elementY } = await element.getRect();
        (await this.getCurrentPage()).mouse.move(elementX + x, elementY + y);
        (await this.getCurrentPage()).mouse.wheel(deltaX, deltaY);
    }
    async scrollByMouseWheel(x, y, deltaX, deltaY, duration) {
        internals_1.promodLogger.engineLog(`[PW] Promod client interface calls method "scrollByMouseWheel" from wrapped API, args: `, x, y, deltaX, deltaY, duration);
        (await this.getCurrentPage()).mouse.move(x, y);
        (await this.getCurrentPage()).mouse.wheel(deltaX, deltaY);
    }
    async keyboardPressEsc() {
        await (await this.getCurrentPage()).keyboard.down('Escape');
        await (await this.getCurrentPage()).keyboard.up('Escape');
    }
    async keyboardPressEnter() {
        await (await this.getCurrentPage()).keyboard.down('Enter');
        await (await this.getCurrentPage()).keyboard.up('Enter');
    }
}
exports.Browser = Browser;
const browser = Browser.getBrowser();
exports.browser = browser;
//# sourceMappingURL=pw_client.js.map