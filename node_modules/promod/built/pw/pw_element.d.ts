/// <reference types="node" />
import type { PromodElementType, PromodElementsType } from '../interface';
import type { ElementHandle } from 'playwright-core';
declare class PromodElements {
    private _driver;
    private _driverElements;
    private getParent;
    private getExecuteScriptArgs;
    private selector;
    parentSelector: string;
    _browserInterface: any;
    constructor(selector: any, client: any, getParent?: any, getExecuteScriptArgs?: any);
    /**
     * @private
     *
     * @info if index is less than zero we will get element from the end
     * @param {number} index
     * @returns {Promise<ElementHandle>}
     */
    private getElement;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.get(0).click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    get(index: any): PromodElementType;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.last().click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    last(): PromodElementType;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.first().click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    first(): PromodElementType;
    /**
     * @example
     * const buttons = $$('button');
     *
     * const nativeElements = await buttons.getEngineElements();
     *
     * @returns {Promise<ElementHandle[]>}
     */
    getEngineElements(): Promise<ElementHandle<Node>[]>;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.each(async (button) => await button.click());
     *
     * @param {(item, index) => Promise<void>} cb
     */
    each(cb: (item: PromodElementType, index?: number) => Promise<void>): Promise<void>;
    /**
     * @example
     * const buttons = $$('button');
     * const buttonsText = await buttons.map(async (button) => await button.getText());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<any[]>}
     */
    map<T>(cb: (item: PromodElementType, index?: number) => Promise<T>): Promise<T[]>;
    /**
     * @example
     * const buttons = $$('button');
     * const isSomeButtonDisplayed = await buttons.some(async (button) => await button.isDisplayed());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<boolean>}
     */
    some(cb: (item: PromodElementType, index?: number) => Promise<boolean>): Promise<boolean>;
    /**
     * @example
     * const buttons = $$('button');
     * const isEveryButtonDisplayed = await buttons.every(async (button) => await button.isDisplayed());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<boolean>}
     */
    every(cb: (item: PromodElementType, index?: number) => Promise<boolean>): Promise<boolean>;
    /**
     * @example
     * const buttons = $$('button');
     * const button = await buttons.find(async (button) => await button.getText() === 'Click me');
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<PromodElementType>}
     */
    find(cb: (item: PromodElementType, index?: number) => Promise<boolean>): Promise<PromodElementType>;
    /**
     * @example
     * const buttons = $$('button');
     * const buttonsCount = await buttons.count();
     *
     * @returns {Promise<number>}
     */
    count(): Promise<number>;
}
declare class PromodElement {
    private _driver;
    private _driverElement;
    private getParent;
    private getExecuteScriptArgs;
    private useParent;
    selector: string;
    parentSelector: string;
    _browserInterface: any;
    constructor(selector: any, client: any, getParent?: any, getExecuteScriptArgs?: any, useParent?: any);
    /**
     * @private
     * @returns {Promise<ElementHandle<Node>>}
     */
    private getElement;
    /**
     * @example
     * const button = $('button');
     *
     * @param {string|Function} selector
     * @param {any[]} rest
     * @returns {PromodElementType}
     */
    $(selector: any, ...rest: any[]): PromodElementType;
    /**
     * @example
     * const buttons = $$('button');
     *
     * @param {string|Function} selector
     * @param {any[]} rest
     * @returns {PromodElementsType}
     */
    $$(selector: any, ...rest: any[]): PromodElementsType;
    /**
     * @example
     * const button = $('button');
     * await button.click();
     *
     * @param {object} [opts] clickOpts
     * @param {boolean} [opts.withScroll] withScroll
     * @param {'left' | 'right' | 'middle'} [opts.button] button
     * @param {number} [opts.clickCount] clickCount
     * @param {number} [opts.delay] delay
     * @param {boolean} [opts.force] force
     * @param {Array<'Alt' | 'Control' | 'Meta' | 'Shift'>} [opts.modifiers] modifiers
     * @param {boolean} [opts.noWaitAfter] noWaitAfter
     * @param {{ x: number; y: number }} [opts.position] position
     * @param {number} [opts.timeout] timeout
     * @param {boolean} [opts.trial] trial
     * @returns {Promise<void>}
     */
    click(opts?: {
        withScroll?: boolean;
        button?: 'left' | 'right' | 'middle';
        clickCount?: number;
        delay?: number;
        force?: boolean;
        modifiers?: Array<'Alt' | 'Control' | 'Meta' | 'Shift'>;
        noWaitAfter?: boolean;
        position?: {
            x: number;
            y: number;
        };
        allowForceIfIntercepted?: boolean;
        timeout?: number;
        trial?: boolean;
    }): Promise<void>;
    /**
     *
     * @example
     * const button = $('button');
     * const tag = await button.getTagName();
     *
     * @returns {Promise<string>}
     */
    getTagName(): Promise<any>;
    getCssValue(): Promise<void>;
    getAttribute(attribute: string): Promise<string>;
    getRect(): Promise<{
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    isEnabled(): Promise<boolean>;
    isSelected(): Promise<boolean>;
    /**
     * @example works with Enter, need improve for another Keys
     *
     * @param value
     */
    sendKeys(value: string | number, asFill?: boolean): Promise<void>;
    /**
     * @example
     * const button = $('button')
     * await button.hover()
     *
     * @returns {Promise<void>}
     */
    hover(): Promise<void>;
    /**
     * @example
     * const button = $('button')
     * await button.clickByElementCoordinate('center-top')
     *
     * @param {string} position
     * @returns {Promise<void>}
     */
    clickByElementCoordinate(position?: 'center' | 'center-top' | 'center-bottom' | 'center-right' | 'center-left' | 'right-top' | 'right-bottom' | 'left-top' | 'left-bottom'): Promise<void>;
    getElementCoordinates(position?: 'center' | 'center-top' | 'center-bottom' | 'center-right' | 'center-left' | 'right-top' | 'right-bottom' | 'left-top' | 'left-bottom'): Promise<{
        x: number;
        y: number;
    }>;
    focus(): Promise<void>;
    /**
     * @example
     * const txt = '123';
     * const inpt = $('input');
     * await inpt.sendKeys(txt);
     * await inpt.pressEnter(true);
     *
     * @param {boolean} [focus] should element got focus event before execute enter
     *
     * @returns {Promise<void>}
     */
    pressEnter(focus?: boolean): Promise<void>;
    /**
     * @example
     * const txt = '123';
     * const inpt = $('input');
     * await inpt.sendKeys(txt);
     * await inpt.clearViaBackspace(txt.length, true);
     *
     * @param {number} repeat how many times execute back space
     * @param {boolean} [focus] should element got focus event before execute back space
     *
     * @returns {Promise<void>}
     */
    clearViaBackspace(repeat?: number, focus?: boolean): Promise<void>;
    selectOption(value: string | {
        /**
         * Matches by `option.value`. Optional.
         */
        value?: string;
        /**
         * Matches by `option.label`. Optional.
         */
        label?: string;
        /**
         * Matches by the index. Optional.
         */
        index?: number;
    }, strictTextOptionEqual?: boolean): Promise<string[]>;
    clear(): Promise<void>;
    submit(): Promise<void>;
    getText(): Promise<string>;
    /**
     * @returns {Promise<Buffer>}
     */
    takeScreenshot(): Promise<Buffer>;
    /**
     *
     * @param {'end' | 'start' | 'center' | 'nearest'} [position] scroll position
     * @returns {Promise<void>}
     */
    scrollIntoView(position?: 'end' | 'start' | 'center' | 'nearest'): Promise<void>;
    private getEngineElement;
    /**
     * @returns {Promise<boolean>} button is present
     * @example
     * const button = $('button')
     * const buttonIsDisplayed = await button.isDisplayed();
     */
    isDisplayed(): Promise<boolean>;
    /**
     * @returns {Promise<boolean>} button is present
     * @example
     * const button = $('button')
     * const buttonIsPresent = await button.isPresent();
     */
    isPresent(): Promise<boolean>;
    locator(): {
        value: string;
    };
    private isInteractionIntercepted;
}
declare const $: (selector: string | Promise<any> | ((...args: any[]) => any), root?: PromodElementType | any, ...rest: any[]) => PromodElementType;
declare const $$: (selector: string | Promise<any> | ((...args: any[]) => any), root?: PromodElementType | any, ...rest: any[]) => PromodElementsType;
declare function preBindBrowserInstance(browserThaNeedsToBeBinded: any): {
    $: (selector: string | Promise<any> | ((...args: any[]) => any), root?: PromodElementType | any, ...rest: any[]) => PromodElementType;
    $$: (selector: string | Promise<any> | ((...args: any[]) => any), root?: PromodElementType | any, ...rest: any[]) => PromodElementsType;
    browser: any;
};
export { $, $$, PromodElement, PromodElements, preBindBrowserInstance };
