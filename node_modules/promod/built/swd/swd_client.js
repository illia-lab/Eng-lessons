"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Browser = exports.browser = void 0;
const sat_utils_1 = require("sat-utils");
const selenium_webdriver_1 = require("selenium-webdriver");
const execute_script_1 = require("../helpers/execute.script");
const swd_alignment_1 = require("./swd_alignment");
const mappers_1 = require("../mappers");
const internals_1 = require("../internals");
const availableToRunEvenIfCurrentDriverDoesNotExist = ['constructor', 'runNewBrowser', 'switchToBrowser', 'quitAll'];
function validateBrowserCallMethod(browserClass) {
    const protKeys = Object.getOwnPropertyNames(browserClass.prototype).filter((item) => !availableToRunEvenIfCurrentDriverDoesNotExist.includes(item));
    for (const key of protKeys) {
        const descriptor = Object.getOwnPropertyDescriptor(browserClass.prototype, key);
        if ((0, sat_utils_1.isAsyncFunction)(descriptor.value)) {
            const originalMethod = descriptor.value;
            // eslint-disable-next-line no-inner-declarations
            async function decoratedWithChecker(...args) {
                if (!this.seleniumDriver) {
                    throw new Error(`
${key}(): Seems like driver was not initialized, please check how or where did you call getDriver function
or visit https://github.com/Simple-Automation-Testing/promod/blob/master/docs/init.md#getdriver
					`);
                }
                return originalMethod.call(this, ...args);
            }
            Object.defineProperty(decoratedWithChecker, 'name', { value: key });
            descriptor.value = decoratedWithChecker;
            Object.defineProperty(browserClass.prototype, key, descriptor);
        }
    }
    return new browserClass();
}
class Browser {
    static getBrowser() {
        return validateBrowserCallMethod(Browser);
    }
    constructor() {
        this.wait = sat_utils_1.waitForCondition;
        this.wait = sat_utils_1.waitForCondition;
        this.seleniumDriver;
    }
    currentClient() {
        return this.seleniumDriver;
    }
    get keyboard() {
        return mappers_1.KeysSWD;
    }
    injectEngine({ driver }) {
        this.seleniumDriver = driver;
    }
    async setBasicAuth(authData, dontThrowOnError = true) {
        try {
            const page = await this.seleniumDriver.createCDPConnection('page');
            await this.seleniumDriver.register(authData.username, authData.password, page);
        }
        catch (error) {
            if (dontThrowOnError) {
                console.error(error);
            }
            else {
                throw error;
            }
        }
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser, $ } = seleniumWD;
     *
     * await browser.scrollByMouseWheel($('.scroll.me'), 10, 10, 1, 1, 250)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async scrollElementByMouseWheel(element, x, y, deltaX, deltaY, duration) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "scrollElementByMouseWheel" from wrapped API, args: `, element, x, y, deltaX, deltaY, duration);
        await this.seleniumDriver
            .actions()
            // @ts-ignore
            .scroll(x, y, deltaX, deltaY, await element.getEngineElement(), duration)
            .perform();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.scrollByMouseWheel(10, 10, 1, 1, 250)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async scrollByMouseWheel(x, y, deltaX, deltaY, duration) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "scrollByMouseWheel" from wrapped API, args: `, x, y, deltaX, deltaY, duration);
        await this.seleniumDriver
            .actions()
            // @ts-ignore
            .scroll(x, y, deltaX, deltaY, undefined, duration)
            .perform();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.keyDownAndHold(browser.keyboard.PageDown)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async keyDownAndHold(key, element) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "keyDownAndHold" from wrapped API, args: `, key, element);
        if (element) {
            await this.seleniumDriver
                .actions()
                .move({ origin: (await element.getEngineElement()) })
                .keyDown(key)
                .perform();
        }
        else {
            await this.seleniumDriver.actions().keyDown(key).perform();
        }
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.keyUp(browser.keyboard.PageDown)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async keyUp(key, element) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "keyUp" from wrapped API, args: `, key, element);
        if (element) {
            await this.seleniumDriver
                .actions()
                .move({ origin: (await element.getEngineElement()) })
                .keyUp(key)
                .perform();
        }
        else {
            await this.seleniumDriver.actions().keyUp(key).perform();
        }
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.keyDownAndUp(browser.keyboard.PageDown)
     *
     * @param {string} key key that needs to press down
     * @return {Promise<void>}
     */
    async keyDownAndUp(key, element) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "keyUp" from wrapped API, args: `, key, element);
        if (element) {
            await this.seleniumDriver
                .actions()
                .move({ origin: (await element.getEngineElement()) })
                .keyDown(key)
                .keyUp(key)
                .perform();
        }
        else {
            await this.seleniumDriver.actions().keyDown(key).keyUp(key).perform();
        }
    }
    /**
     *
     * @param {object} [browserDescription] browser descriptions
     */
    async runNewBrowser({ currentBrowserName, newBrowserName, capabilities, } = {}) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "runNewBrowser" from wrapped API, args: `, currentBrowserName, newBrowserName, capabilities);
        if (!this._createNewDriver) {
            throw new Error('createNewDriver(): seems like create driver method was not inited');
        }
        if (!(0, sat_utils_1.isArray)(this.drivers)) {
            this.drivers = [];
        }
        if (this.seleniumDriver && currentBrowserName) {
            this.seleniumDriver['__promodBrowserName'] = currentBrowserName;
        }
        if (this.seleniumDriver) {
            this.drivers.push(this.seleniumDriver);
        }
        const { driver } = await this._createNewDriver(capabilities);
        if (newBrowserName) {
            driver['__promodBrowserName'] = newBrowserName;
        }
        this.seleniumDriver = driver;
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.switchToIframe('my-iframe');
     *
     * @param {string} selector iframe selector
     * @param {boolean} [jumpToDefaultFirst] should switch to top frame first
     * @return {Promise<void>}
     */
    async switchToIframe(selector, jumpToDefaultFirst = false, { timeout = 30000, message = '' } = {}) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "switchToIframe" from wrapped API, args: `, selector, jumpToDefaultFirst);
        if (jumpToDefaultFirst) {
            await this.switchToDefauldIframe();
        }
        await (0, sat_utils_1.waitForCondition)(async () => {
            const elements = await this.seleniumDriver.findElements((0, swd_alignment_1.buildBy)(selector));
            return elements.length > 0;
        }, {
            timeout,
            message: (t, e = 'without error') => `switchToIframe('${selector}'): required iframe was not found, timeout ${t}, error: ${e} ${message ? '\n' + message : ''} `,
        });
        await this.seleniumDriver.switchTo().frame(this.seleniumDriver.findElement((0, swd_alignment_1.buildBy)(selector)));
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.switchToDefauldIframe();
     *
     * @return {Promise<void>}
     */
    async switchToDefauldIframe() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "switchToDefauldIframe" from wrapped API`);
        await this.seleniumDriver.switchTo().defaultContent();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.switchToBrowser();
     *
     * @return {Promise<void>}
     */
    async switchToBrowser(browserData = {}) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "switchToBrowser" from wrapped API, args: `, browserData);
        const { index, browserName } = browserData, tabData = __rest(browserData, ["index", "browserName"]);
        if (this.seleniumDriver && this.drivers && this.drivers.length) {
            const isDriverInPool = this.drivers.find((item) => item === this.seleniumDriver);
            if (!isDriverInPool) {
                this.drivers = [...this.drivers, this.seleniumDriver];
            }
        }
        if ((0, sat_utils_1.isString)(browserName)) {
            const driver = this.drivers.find((item) => item['__promodBrowserName'] === browserName);
            // TODO find better solution
            if (!driver) {
                throw new Error(`Browser with name ${browserName} not found`);
            }
            this.seleniumDriver = driver;
            return;
        }
        if ((0, sat_utils_1.isNumber)(index) && (0, sat_utils_1.isArray)(this.drivers) && this.drivers.length > index) {
            // TODO find better solution
            this.seleniumDriver = this.drivers[index];
            return;
        }
        if ((0, sat_utils_1.isNotEmptyObject)(tabData)) {
            for (const driver of this.drivers) {
                this.seleniumDriver = driver;
                const result = await this.switchToBrowserTab(Object.assign({}, tabData))
                    .then(() => true, () => false)
                    .catch(() => false);
                if (result) {
                    const index = this.drivers.findIndex((item) => item === this.seleniumDriver);
                    this.seleniumDriver = this.drivers[index];
                    return;
                }
            }
        }
        throw new Error(`switchToBrowser(): required browser was not found`);
    }
    set setCreateNewDriver(driverCreator) {
        this._createNewDriver = driverCreator;
    }
    setClient(client) {
        this.seleniumDriver = client;
    }
    get Key() {
        return selenium_webdriver_1.Key;
    }
    get baseUrl() {
        return this.appBaseUrl;
    }
    set baseUrl(url) {
        this.appBaseUrl = url;
    }
    async returnToInitialTab() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "returnToInitialTab" from wrapped API`);
        // there was no switching in test
        if (!this.initialTab) {
            return;
        }
        await this.closeAllTabsExceptInitial();
        this.seleniumDriver.switchTo().window(this.initialTab);
        // set initialTab to null for further "it" to use
        this.initialTab = null;
    }
    async closeAllTabsExceptInitial() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "closeAllTabsExceptInitial" from wrapped API`);
        const handles = await this.getTabs();
        handles.splice(handles.indexOf(this.initialTab), 1);
        await this.makeActionAtEveryTab(async () => this.close(), handles);
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const tabTitles = [];
     * await browser.makeActionAtEveryTab(async () => {
     *    tabTitles.push(await browser.getTitle());
     * });
     *
     * @param {!Function} action action that needs to be performed
     * @return {Promise<void>}
     */
    async makeActionAtEveryTab(action, handles) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "makeActionAtEveryTab" from wrapped API, args: `, action);
        handles = handles || (await this.getTabs());
        for (const windowHandle of handles) {
            await this.seleniumDriver.switchTo().window(windowHandle);
            await action();
        }
    }
    /**
     * switchToBrowserTab
     * @private
     */
    async switchToBrowserTab(tabObject = {}) {
        const { strictEquality = true, index, expectedQuantity, timeout = 5000 } = tabObject, titleUrl = __rest(tabObject, ["strictEquality", "index", "expectedQuantity", "timeout"]);
        if ((0, sat_utils_1.isNumber)(expectedQuantity)) {
            let errorMessage;
            await (0, sat_utils_1.waitForCondition)(async () => {
                const tabs = await this.getTabs();
                errorMessage = () => `Expected browser tabs count is ${expectedQuantity}, current browser tabs count is ${tabs.length}`;
                return tabs.length === expectedQuantity;
            }, { message: errorMessage, timeout });
        }
        if ((0, sat_utils_1.isNumber)(index) && (await this.getTabs()).length < index + 1) {
            throw new Error(`Index is out available browser tabs count, index is ${index}, current browser tabs count is ${(await this.getTabs()).length}`);
        }
        else if ((0, sat_utils_1.isNumber)(index)) {
            return await this.seleniumDriver.switchTo().window((await this.getTabs())[index]);
        }
        if ((0, sat_utils_1.isNotEmptyObject)(titleUrl)) {
            let errorMessage;
            await (0, sat_utils_1.waitForCondition)(async () => {
                const tabs = await this.getTabs();
                for (const tab of tabs) {
                    await this.seleniumDriver.switchTo().window(tab);
                    const currentBrowserState = {
                        url: await this.getCurrentUrl(),
                        title: await this.getTitle(),
                    };
                    const { result } = (0, sat_utils_1.compareToPattern)(currentBrowserState, titleUrl, { stringIncludes: !strictEquality });
                    if (result)
                        return true;
                }
                errorMessage = () => `Expected browser tab state is ${(0, sat_utils_1.safeJSONstringify)(titleUrl)}, current browser tab states was not met`;
            }, { message: errorMessage, timeout });
        }
    }
    /**
     *
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.openNewTab('https://www.npmjs.com/package/promod');
     *
     * @param {string} url url that needs to open in new browser tab
     * @return {Promise<void>}
     */
    async openNewTab(url = 'data:,') {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "openNewTab" from wrapped API, args: `, url);
        await this.seleniumDriver.executeScript((openUrl) => {
            window.open(openUrl, '_blank');
        }, url);
    }
    /**
     *
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.switchToTab({ index: 2, expectedQuantity: 3 });
     *
     * @param {TSwitchBrowserTabPage} tabObject tab description
     * @return {Promise<void>}
     */
    async switchToTab(tabObject) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "switchToTab" from wrapped API, args: `, tabObject);
        if (!this.initialTab) {
            this.initialTab = await this.seleniumDriver.getWindowHandle();
        }
        await this.switchToBrowserTab(tabObject);
    }
    /**
     *
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.setCookies({name: 'test', value: 'test'});
     * @param {TCookie | TCookie[]} cookies cookies object
     * @returns {Promise<void>}
     */
    async setCookies(cookies) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "setCookies" from wrapped API, args: `, cookies);
        const cookiesArr = (0, sat_utils_1.toArray)(cookies);
        for (const cookie of cookiesArr) {
            await (await this.seleniumDriver.manage()).addCookie(cookie);
        }
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const cookies = await browser.getCookies();
     * @return {Promise<Array<TCookie>>} cookies list
     */
    async getCookies() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getCookies" from wrapped API`);
        return await (await this.seleniumDriver.manage()).getCookies();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const cookie = await browser.getCookieByName('test');
     * @param {string} name cookie name
     * @return {Promise<{ name: string; value: string }>}
     */
    async getCookieByName(name) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getCookieByName" from wrapped API, args: `, name);
        return await (await this.seleniumDriver.manage()).getCookie(name);
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.deleteCookie('test');
     * @param {string} name cookie name
     * @returns {Promise<void>}
     */
    async deleteCookie(name) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "deleteCookie" from wrapped API, args: `, name);
        await (await this.seleniumDriver.manage()).deleteCookie(name);
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.deleteAllCookies();
     * @returns {Promise<void>}
     */
    async deleteAllCookies() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "deleteAllCookies" from wrapped API`);
        await (await this.seleniumDriver.manage()).deleteAllCookies();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * cosnt title = await browser.getTitle();
     *
     * @return {Promise<string>} tab (page) title
     */
    async getTitle() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getTitle" from wrapped API`);
        return await this.seleniumDriver.getTitle();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const currentPageUrl = await browser.getCurrentUrl();
     *
     * @return {Promise<string>}
     */
    async getCurrentUrl() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getCurrentUrl" from wrapped API`);
        return await this.seleniumDriver.getCurrentUrl();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * cosnt { height, width } = await browser.getWindomSize();
     *
     * @return {Promise<{ height: number; width: number }>} window size
     */
    async getWindomSize() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getWindomSize" from wrapped API`);
        return await this.seleniumDriver.executeScript(() => ({ height: window.outerHeight, width: window.outerWidth }));
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const currentPageScreenshot = await browser.takeScreenshot();
     *
     * @returns {Promise<Buffer>}
     */
    async takeScreenshot() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "takeScreenshot" from wrapped API`);
        const res = await this.seleniumDriver.takeScreenshot();
        return Buffer.from(res, 'base64');
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const currentPageScreenshot = await browser.getTabs();
     *
     * @returns {Promise<any[]>}
     */
    async getTabs() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getTabs" from wrapped API`);
        return await this.seleniumDriver.getAllWindowHandles();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const currentTabsCount = await browser.getTabsCount();
     *
     * @returns {Promise<number>}
     */
    async getTabsCount() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getTabsCount" from wrapped API`);
        return (await this.seleniumDriver.getAllWindowHandles()).length;
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.get('https://github.com/Simple-Automation-Testing/promod');
     *
     * @param {string} url url that needs to be open
     * @return {Promise<void>}
     */
    async get(url) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "get" from wrapped API`);
        const getUrl = (0, mappers_1.resolveUrl)(url, this.appBaseUrl);
        return await this.seleniumDriver.get(getUrl);
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.setWindowSize(800, 600);
     *
     * @param {number} width window width
     * @param {number} height window height
     * @return {Promise<void>}
     */
    async setWindowSize(width, height) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "setWindowSize" from wrapped API, args: `, width, height);
        return await this.seleniumDriver.manage().window().setRect({
            width,
            height,
        });
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.sleep(800);
     *
     * @param {number} time time in ms
     * @return {Promise<void>}
     */
    async sleep(time) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "sleep" from wrapped API, args: `, time);
        await (() => new Promise((resolve) => setTimeout(resolve, time)))();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const result = await browser.executeScript(() => document.body.offsetHeight);
     *
     * @param {!Function} script scripts that needs to be executed
     * @param {any|any[]} [args] function args
     * @returns {Promise<unknown>}
     */
    async executeScript(script, args) {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "executeScript" from wrapped API, args: `, script, args);
        const recomposedArgs = await (0, execute_script_1.toNativeEngineExecuteScriptArgs)(args);
        const res = await this.seleniumDriver.executeScript(script, recomposedArgs);
        return res;
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.back();
     *
     * @return {Promise<void>}
     */
    async back() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "back" from wrapped API`);
        return (await this.seleniumDriver.navigate()).back();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.forward();
     *
     * @return {Promise<void>}
     */
    async forward() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "forward" from wrapped API`);
        return (await this.seleniumDriver.navigate()).forward();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.refresh();
     *
     * @return {Promise<void>}
     */
    async refresh() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "refresh" from wrapped API`);
        return (await this.seleniumDriver.navigate()).refresh();
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.quit();
     *
     * @return {Promise<void>}
     */
    async quit() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "quit" from wrapped API`);
        if (this.drivers && this.drivers.length) {
            const index = this.drivers.findIndex((driver) => driver === this.seleniumDriver);
            if (index !== -1)
                this.drivers.splice(index, 1);
        }
        await this.seleniumDriver.quit();
        this.seleniumDriver = null;
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.quitAll();
     *
     * @return {Promise<void>}
     */
    async quitAll() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "quitAll" from wrapped API`);
        const drivers = (0, sat_utils_1.toArray)(this.drivers);
        this.drivers = [];
        if (this.seleniumDriver) {
            await this.seleniumDriver.quit();
        }
        this.seleniumDriver = null;
        for (const driver of drivers) {
            await driver.quit().catch((_) => ({}));
        }
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.maximize();
     *
     * @return {Promise<void>}
     */
    async maximize() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "maximize" from wrapped API`);
        const { width, height } = (await this.seleniumDriver.executeScript(() => {
            const { availHeight, availWidth } = window.screen;
            return { width: availWidth, height: availHeight };
        }));
        const manage = await this.seleniumDriver.manage();
        await manage.window().setRect({ width, height });
    }
    /**
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * const browserLogs = await browser.getBrowserLogs();
     *
     * @return {Promise<TLogLevel[] | string>}
     */
    async getBrowserLogs() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "getBrowserLogs" from wrapped API`);
        try {
            // @ts-ignore
            const manage = await this.seleniumDriver.manage();
            return manage.logs().get('browser');
        }
        catch (e) {
            return 'Comman was failed ' + e.toString();
        }
    }
    /**
     * @info
     * when you close current browser and you still have another browser sessions
     * you have to switch to another browser manually via switchToBrowser
     *
     * @example
     * const { seleniumWD } = require('promod');
     * const { browser } = seleniumWD;
     *
     * await browser.close();
     *
     * @return {Promise<void>}
     */
    async close() {
        internals_1.promodLogger.engineLog(`[SWD] Promod client interface calls method "close" from wrapped API`);
        await this.seleniumDriver.close();
    }
}
exports.Browser = Browser;
const browser = Browser.getBrowser();
exports.browser = browser;
//# sourceMappingURL=swd_client.js.map