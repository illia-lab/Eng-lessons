import { By, WebElement } from 'selenium-webdriver';
import type { PromodElementType, PromodElementsType } from '../interface';
declare class PromodSeleniumElements {
    private selector;
    private _driverElements;
    private getParent;
    private getExecuteScriptArgs;
    _browserInterface: any;
    parentSelector: string;
    constructor(selector: any, client?: import("./swd_client").Browser, getParent?: any, getExecuteScriptArgs?: any);
    /**
     * @private
     *
     * @info if index is less than zero we will get element from the end
     * @param {number} index
     * @returns {Promise<WebElement>}
     */
    private getElement;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.get(0).click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    get(index: any): PromodElementType;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.last().click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    last(): PromodElementType;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.first().click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    first(): PromodElementType;
    /**
     * @example
     * const buttons = $$('button');
     *
     * const nativeElements = await buttons.getEngineElements();
     *
     * @returns {Promise<ElementHandle[]>}
     */
    getEngineElements(): Promise<WebElement[]>;
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.each(async (button) => await button.click());
     *
     * @param {(item, index) => Promise<void>} cb
     */
    each(cb: (item: PromodElementType, index?: number) => Promise<void>): Promise<void>;
    /**
     * @example
     * const buttons = $$('button');
     * const buttonsText = await buttons.map(async (button) => await button.getText());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<any[]>}
     */
    map<T>(cb: (item: PromodElementType, index?: number) => Promise<T>): Promise<T[]>;
    /**
     * @example
     * const buttons = $$('button');
     * const isSomeButtonDisplayed = await buttons.some(async (button) => await button.isDisplayed());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<boolean>}
     */
    some(cb: (item: PromodElementType, index?: number) => Promise<boolean>): Promise<boolean>;
    /**
     * @example
     * const buttons = $$('button');
     * const isEveryButtonDisplayed = await buttons.every(async (button) => await button.isDisplayed());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<boolean>}
     */
    every(cb: (item: PromodElementType, index?: number) => Promise<boolean>): Promise<boolean>;
    /**
     * @example
     * const buttons = $$('button');
     * const button = await buttons.find(async (button) => await button.getText() === 'Click me');
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<PromodElementType>}
     */
    find(cb: (item: PromodElementType, index?: number) => Promise<boolean>): Promise<PromodElementType>;
    /**
     * @example
     * const buttons = $$('button');
     * const buttonsCount = await buttons.count();
     *
     * @returns {Promise<number>}
     */
    count(): Promise<number>;
}
declare class PromodSeleniumElement {
    private selector;
    private _driverElement;
    private getParent;
    private getExecuteScriptArgs;
    private useParent;
    _browserInterface: any;
    parentSelector: string;
    constructor(selector: any, client?: import("./swd_client").Browser, getParent?: any, getExecuteScriptArgs?: any, useParent?: any);
    /**
     * @private
     * @returns {Promise<WebElement>}
     */
    private getElement;
    /**
     * @example
     * const button = $('button');
     *
     * @param {string|Function} selector
     * @param {any[]} rest
     * @returns {PromodElementType}
     */
    $(selector: any, ...rest: any[]): PromodElementType;
    /**
     * @example
     * const buttons = $$('button');
     *
     * @param {string|Function} selector
     * @param {any[]} rest
     * @returns {PromodElementsType}
     */
    $$(selector: any, ...rest: any[]): PromodElementsType;
    /**
     * @example
     * const button = $('button');
     * await button.click(); // regular click
     * await button.click({ withScroll: true }); // first element will be scrolled to view port and then regular click
     * await button.click({ allowForceIfIntercepted: true }); // if regular click is intercepted by another element, click will be re-executed by element x,y center coordinates
     *
     * @param {object} [opts] clickOpts
     * @param {boolean} [opts.withScroll] withScroll
     * @param {'left' | 'right' | 'middle'} [opts.button] button
     * @param {number} [opts.clickCount] clickCount
     * @param {number} [opts.delay] delay
     * @param {boolean} [opts.force] force
     * @param {Array<'Alt' | 'Control' | 'Meta' | 'Shift'>} [opts.modifiers] modifiers
     * @param {boolean} [opts.noWaitAfter] noWaitAfter
     * @param {{ x: number; y: number }} [opts.position] position
     * @param {number} [opts.timeout] timeout
     * @param {boolean} [opts.trial] trial
     * @param {boolean} [opts.allowForceIfIntercepted] allowForceIfIntercepted
     * @returns {Promise<void>}
     */
    click(opts?: {
        withScroll?: boolean;
        allowForceIfIntercepted?: boolean;
        button?: 'left' | 'right' | 'middle';
        clickCount?: number;
        delay?: number;
        force?: boolean;
        modifiers?: Array<'Alt' | 'Control' | 'Meta' | 'Shift'>;
        noWaitAfter?: boolean;
        position?: {
            x: number;
            y: number;
        };
        timeout?: number;
        trial?: boolean;
    }): Promise<void>;
    sendKeys(value: any, asFill: any): Promise<void>;
    /**
     * @example
     * const button = $('button')
     * await button.hover()
     *
     * @returns {Promise<void>}
     */
    hover(): Promise<void>;
    /**
     * @example
     * const button = $('button')
     * await button.clickByElementCoordinate('center-top')
     *
     * @param {string} position
     * @returns {Promise<void>}
     */
    clickByElementCoordinate(position?: 'center' | 'center-top' | 'center-bottom' | 'center-right' | 'center-left' | 'right-top' | 'right-bottom' | 'left-top' | 'left-bottom'): Promise<void>;
    getElementCoordinates(position?: 'center' | 'center-top' | 'center-bottom' | 'center-right' | 'center-left' | 'right-top' | 'right-bottom' | 'left-top' | 'left-bottom'): Promise<{
        x: number;
        y: number;
    }>;
    focus(): Promise<void>;
    scrollIntoView(position?: 'end' | 'start' | 'center'): Promise<void>;
    /**
     * @example
     * const button = $('button')
     * await button.isDisplayed() // boolean - true|false
     *
     * @returns {Promise<boolean>} button is present
     */
    isDisplayed(): Promise<boolean>;
    /**
     * @example
     * const txt = '123';
     * const inpt = $('input');
     * await inpt.sendKeys(txt);
     * await inpt.clearViaBackspace(txt.length, true);
     *
     * @param {number} repeat how many times execute back space
     * @param {boolean} [focus] should element got focus event before execute back space
     *
     * @returns {Promise<void>}
     */
    clearViaBackspace(repeat?: number, focus?: boolean): Promise<void>;
    /**
     * @example
     * const txt = '123';
     * const inpt = $('input');
     * await inpt.sendKeys(txt);
     * await inpt.pressEnter(true);
     *
     * @param {boolean} [focus] should element got focus event before execute enter
     *
     * @returns {Promise<void>}
     */
    pressEnter(focus?: boolean): Promise<void>;
    selectOption(optValue: {
        value?: string;
        label?: string;
        index?: number;
    } | string): Promise<void>;
    /**
     * @example
     * const button = $('button')
     * const buttonIsPresent = await button.isPresent();
     *
     * @returns {Promise<boolean>} button is present
     */
    isPresent(): Promise<boolean>;
    private callElementAction;
    getId(): Promise<any>;
    getEngineElement(): Promise<WebElement>;
    locator(): {
        value: string;
    };
    private isInteractionIntercepted;
}
declare const $: (selector: string | Promise<any> | By | ((...args: any[]) => any), root?: PromodElementType | any, ...rest: any[]) => PromodElementType;
declare function $$(selector: string | By | ((...args: any[]) => any) | Promise<any>, root?: PromodElementType | any, ...rest: any[]): PromodElementsType;
declare function preBindBrowserInstance(browserThaNeedsToBeBinded: any): {
    browser: any;
    $$: (selector: string | Promise<any> | By | ((...args: any[]) => any), root?: PromodElementType | any, ...rest: any[]) => PromodElementsType;
    $: (selector: string | Promise<any> | By | ((...args: any[]) => any), root?: PromodElementType | any, ...rest: any[]) => PromodElementType;
};
export { $, $$, PromodSeleniumElement, PromodSeleniumElements, By, preBindBrowserInstance };
