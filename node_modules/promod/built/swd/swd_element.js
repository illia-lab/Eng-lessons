"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preBindBrowserInstance = exports.By = exports.PromodSeleniumElements = exports.PromodSeleniumElement = exports.$$ = exports.$ = void 0;
/* eslint-disable max-len */
const sat_utils_1 = require("sat-utils");
const selenium_webdriver_1 = require("selenium-webdriver");
Object.defineProperty(exports, "By", { enumerable: true, get: function () { return selenium_webdriver_1.By; } });
const swd_client_1 = require("./swd_client");
const swd_alignment_1 = require("./swd_alignment");
const mappers_1 = require("../mappers");
const internals_1 = require("../internals");
const SELENIUM_API_METHODS = [
    'getTagName',
    'getCssValue',
    'getAttribute',
    'getText',
    'getRect',
    'isEnabled',
    'isSelected',
    'submit',
    'clear',
    'getId',
    'takeScreenshot',
];
class PromodSeleniumElements {
    constructor(selector, client = swd_client_1.browser, getParent, getExecuteScriptArgs) {
        this._browserInterface = client;
        this.selector = selector;
        this.getParent = getParent;
        this.getExecuteScriptArgs = getExecuteScriptArgs;
    }
    /**
     * @private
     *
     * @info if index is less than zero we will get element from the end
     * @param {number} index
     * @returns {Promise<WebElement>}
     */
    async getElement(index) {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "getElement" from wrapped API, args: `, index);
        const _driver = this._browserInterface.currentClient();
        const ignoreParent = (0, sat_utils_1.isString)(this.selector) && this.selector.startsWith('ignore-parent=');
        const selector = ignoreParent ? this.selector.replace('ignore-parent=', '') : this.selector;
        if (this.getParent && !ignoreParent && (0, sat_utils_1.isString)(selector)) {
            let parent = await this.getParent();
            if (parent.getEngineElement) {
                // @ts-ignore
                parent = await parent.getEngineElement();
            }
            this._driverElements = await parent.findElements((0, swd_alignment_1.buildBy)(selector, this.getExecuteScriptArgs));
        }
        else {
            this._driverElements = await _driver.findElements((0, swd_alignment_1.buildBy)(selector, this.getExecuteScriptArgs));
        }
        if (index < 0) {
            return this._driverElements[this._driverElements.length + index];
        }
        return this._driverElements[index];
    }
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.get(0).click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    get(index) {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "get" from wrapped API, args: `, index);
        const childElement = new PromodSeleniumElement(this.selector, this._browserInterface, this.getElement.bind(this, index), null, true);
        if (this.parentSelector) {
            childElement.parentSelector = this.parentSelector || this.selector;
        }
        return childElement;
    }
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.last().click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    last() {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "last" from wrapped API`);
        return this.get(-1);
    }
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.first().click();
     *
     * @param {number} index
     * @returns {PromodElementType}
     */
    first() {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "first" from wrapped API`);
        return this.get(0);
    }
    /**
     * @example
     * const buttons = $$('button');
     *
     * const nativeElements = await buttons.getEngineElements();
     *
     * @returns {Promise<ElementHandle[]>}
     */
    async getEngineElements() {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "getEngineElements" from wrapped API`);
        await this.getElement(0);
        return this._driverElements;
    }
    /**
     * @example
     *
     * const buttons = $$('button');
     * await buttons.each(async (button) => await button.click());
     *
     * @param {(item, index) => Promise<void>} cb
     */
    async each(cb) {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "each" from wrapped API, args: `, cb);
        await this.getElement(0);
        for (let i = 0; i < this._driverElements.length; i++) {
            await cb(this.get(i), i);
        }
    }
    /**
     * @example
     * const buttons = $$('button');
     * const buttonsText = await buttons.map(async (button) => await button.getText());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<any[]>}
     */
    async map(cb) {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "map" from wrapped API, args: `, cb);
        await this.getElement(0);
        const res = [];
        for (let i = 0; i < this._driverElements.length; i++) {
            res.push(await cb(this.get(i), i));
        }
        return res;
    }
    /**
     * @example
     * const buttons = $$('button');
     * const isSomeButtonDisplayed = await buttons.some(async (button) => await button.isDisplayed());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<boolean>}
     */
    async some(cb) {
        internals_1.promodLogger.engineLog(`[PW] Promod elements interface calls method "some" from wrapped API, args: `, cb);
        await this.getElement(0);
        for (let i = 0; i < this._driverElements.length; i++) {
            const res = await cb(this.get(i), i).catch(() => false);
            if (res) {
                return res;
            }
        }
        return false;
    }
    /**
     * @example
     * const buttons = $$('button');
     * const isEveryButtonDisplayed = await buttons.every(async (button) => await button.isDisplayed());
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<boolean>}
     */
    async every(cb) {
        internals_1.promodLogger.engineLog(`[PW] Promod elements interface calls method "every" from wrapped API, args: `, cb);
        await this.getElement(0);
        for (let i = 0; i < this._driverElements.length; i++) {
            const res = await cb(this.get(i), i).catch(() => false);
            if (!res) {
                return res;
            }
        }
        return true;
    }
    /**
     * @example
     * const buttons = $$('button');
     * const button = await buttons.find(async (button) => await button.getText() === 'Click me');
     *
     * @param {(item, index) => Promise<any>} cb
     * @returns {Promise<PromodElementType>}
     */
    async find(cb) {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "find" from wrapped API, args: `, cb);
        await this.getElement(0);
        for (let i = 0; i < this._driverElements.length; i++) {
            const el = this.get(i);
            if (await cb(el, i)) {
                return el;
            }
        }
        throw new Error(`Element with selector ${this.selector} was not found`);
    }
    /**
     * @example
     * const buttons = $$('button');
     * const buttonsCount = await buttons.count();
     *
     * @returns {Promise<number>}
     */
    async count() {
        internals_1.promodLogger.engineLog(`[SWD] Promod elements interface calls method "count" from wrapped API`);
        return this.getElement()
            .then(() => this._driverElements.length)
            .catch((error) => {
            internals_1.promodLogger.engineLog(`Promod elements interface gets error after method "count" from wrapped API, error: `, error);
            return 0;
        });
    }
}
exports.PromodSeleniumElements = PromodSeleniumElements;
class PromodSeleniumElement {
    constructor(selector, client = swd_client_1.browser, getParent, getExecuteScriptArgs, useParent) {
        this._browserInterface = client;
        this.selector = selector;
        this.getParent = getParent;
        this.getExecuteScriptArgs = getExecuteScriptArgs;
        this.useParent = useParent;
        const self = this;
        SELENIUM_API_METHODS.forEach(function (methodName) {
            self[methodName] = (...args) => {
                internals_1.promodLogger.engineLog(`Promod element interface calls method "${methodName}" from selenium native API, args: `, ...args);
                const action = () => self._driverElement[methodName].call(self._driverElement, ...args);
                return self.callElementAction(action);
            };
        });
    }
    /**
     * @private
     * @returns {Promise<WebElement>}
     */
    async getElement() {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "getElement" from wrapped API`);
        const _driver = (this._browserInterface || swd_client_1.browser).currentClient();
        const ignoreParent = (0, sat_utils_1.isString)(this.selector) && this.selector.startsWith('ignore-parent=');
        const selector = ignoreParent ? this.selector.replace('ignore-parent=', '') : this.selector;
        /**
         * !@info
         * selector should be a string type to proceed inside if block
         */
        if (this.getParent && !ignoreParent && (0, sat_utils_1.isString)(selector)) {
            let parent = (await this.getParent());
            if (!parent) {
                throw new Error(this.useParent
                    ? `Any element with selector ${this.selector} was not found`
                    : `Parent element with selector ${this.parentSelector} was not found`);
            }
            if (parent.getEngineElement) {
                parent = await parent.getEngineElement();
            }
            if (this.useParent) {
                this._driverElement = parent;
            }
            else {
                this._driverElement = await parent.findElement((0, swd_alignment_1.buildBy)(selector, this.getExecuteScriptArgs));
            }
        }
        else {
            this._driverElement = await _driver.findElement((0, swd_alignment_1.buildBy)(selector, this.getExecuteScriptArgs));
        }
        return this._driverElement;
    }
    /**
     * @example
     * const button = $('button');
     *
     * @param {string|Function} selector
     * @param {any[]} rest
     * @returns {PromodElementType}
     */
    $(selector, ...rest) {
        internals_1.promodLogger.engineLog('[SWD] Create new promod child element, selector: ', selector);
        const [, executeScriptArgsGetter] = getInitElementRest(selector, null, ...rest);
        const childElement = new PromodSeleniumElement(selector, this._browserInterface, this.getElement.bind(this), executeScriptArgsGetter);
        childElement.parentSelector = this.selector;
        return childElement;
    }
    /**
     * @example
     * const buttons = $$('button');
     *
     * @param {string|Function} selector
     * @param {any[]} rest
     * @returns {PromodElementsType}
     */
    $$(selector, ...rest) {
        internals_1.promodLogger.engineLog('[SWD] Create new promod child elements, selector: ', selector);
        const [, executeScriptArgsGetter] = getInitElementRest(selector, null, ...rest);
        const childElements = new PromodSeleniumElements(selector, this._browserInterface, this.getElement.bind(this), executeScriptArgsGetter);
        childElements.parentSelector = this.selector;
        return childElements;
    }
    /**
     * @example
     * const button = $('button');
     * await button.click(); // regular click
     * await button.click({ withScroll: true }); // first element will be scrolled to view port and then regular click
     * await button.click({ allowForceIfIntercepted: true }); // if regular click is intercepted by another element, click will be re-executed by element x,y center coordinates
     *
     * @param {object} [opts] clickOpts
     * @param {boolean} [opts.withScroll] withScroll
     * @param {'left' | 'right' | 'middle'} [opts.button] button
     * @param {number} [opts.clickCount] clickCount
     * @param {number} [opts.delay] delay
     * @param {boolean} [opts.force] force
     * @param {Array<'Alt' | 'Control' | 'Meta' | 'Shift'>} [opts.modifiers] modifiers
     * @param {boolean} [opts.noWaitAfter] noWaitAfter
     * @param {{ x: number; y: number }} [opts.position] position
     * @param {number} [opts.timeout] timeout
     * @param {boolean} [opts.trial] trial
     * @param {boolean} [opts.allowForceIfIntercepted] allowForceIfIntercepted
     * @returns {Promise<void>}
     */
    async click(opts = { clickCount: 1 }) {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "click" from wrapped API, args: `, opts);
        if (!(0, sat_utils_1.isObject)(opts) && !(0, sat_utils_1.isUndefined)(opts)) {
            throw new TypeError(`click(); accepts only object type ${(0, sat_utils_1.getType)(opts)}`);
        }
        const { withScroll, allowForceIfIntercepted } = opts;
        await this.getElement();
        if (withScroll) {
            await this.scrollIntoView('center');
        }
        if (opts.force) {
            return await this.clickByElementCoordinate();
        }
        let scrollableClickResult = await this._driverElement.click().catch((err) => err);
        if (scrollableClickResult) {
            const { isReadyToForce } = await this.isInteractionIntercepted(scrollableClickResult);
            if (isReadyToForce && allowForceIfIntercepted) {
                scrollableClickResult = await this.clickByElementCoordinate('left-top').catch((err) => err);
            }
        }
        if (scrollableClickResult) {
            throw scrollableClickResult;
        }
    }
    async sendKeys(value, asFill) {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "sendKeys" from wrapped API, args: `, value);
        if (!(0, sat_utils_1.isString)(value) && !(0, sat_utils_1.isNumber)(value)) {
            throw new TypeError(`sendKeys(); accepts only string or number value type ${(0, sat_utils_1.getType)(value)}`);
        }
        await this.getElement();
        await this._driverElement.sendKeys(value);
    }
    /**
     * @example
     * const button = $('button')
     * await button.hover()
     *
     * @returns {Promise<void>}
     */
    async hover() {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "hover" from wrapped API`);
        await swd_client_1.browser
            .currentClient()
            .actions()
            .move({ origin: await this.getEngineElement() })
            .perform();
    }
    /**
     * @example
     * const button = $('button')
     * await button.clickByElementCoordinate('center-top')
     *
     * @param {string} position
     * @returns {Promise<void>}
     */
    async clickByElementCoordinate(position = 'center') {
        internals_1.promodLogger.engineLog(`Promod element interface calls method "clickByElementCoordinate" from wrapped API, args: `, position);
        const { x, y } = await this.getElementCoordinates(position);
        await swd_client_1.browser
            .currentClient()
            .actions()
            .move({ x: Math.round(x), y: Math.round(y) })
            .click()
            .perform();
    }
    async getElementCoordinates(position = 'center') {
        internals_1.promodLogger.engineLog(`Promod element interface calls method "getElementCoordinates" from wrapped API, args: `, position);
        await this.getElement();
        const { x, y, width, height } = await this._driverElement.getRect();
        return (0, mappers_1.getPositionXY)(position, { x, y, width, height });
    }
    async focus() {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "focus" from wrapped API`);
        await swd_client_1.browser
            .currentClient()
            .actions()
            .move({ origin: await this.getEngineElement() })
            .press()
            .perform();
    }
    async scrollIntoView(position) {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "scrollIntoView" from wrapped API, args: `, position);
        await this.getElement();
        await this._browserInterface.executeScript(([elem, scrollPosition]) => {
            let position;
            const scrollBlock = ['end', 'start', 'center', 'nearest'];
            if (scrollBlock.includes(scrollPosition)) {
                position = { block: scrollPosition };
            }
            elem.scrollIntoView(position || true);
        }, [await this.getEngineElement(), position]);
    }
    /**
     * @example
     * const button = $('button')
     * await button.isDisplayed() // boolean - true|false
     *
     * @returns {Promise<boolean>} button is present
     */
    async isDisplayed() {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "isDisplayed" from wrapped API`);
        return this.getElement()
            .then(() => this._driverElement.isDisplayed())
            .catch((error) => {
            internals_1.promodLogger.engineLog(`Promod element interface gets error after method "isDisplayed" from wrapped API, error: `, error);
            return false;
        });
    }
    /**
     * @example
     * const txt = '123';
     * const inpt = $('input');
     * await inpt.sendKeys(txt);
     * await inpt.clearViaBackspace(txt.length, true);
     *
     * @param {number} repeat how many times execute back space
     * @param {boolean} [focus] should element got focus event before execute back space
     *
     * @returns {Promise<void>}
     */
    async clearViaBackspace(repeat = 1, focus) {
        internals_1.promodLogger.engineLog(`Promod element interface calls method "clearViaBackspace" from wrapped API, args: `, repeat, focus);
        await this.getElement();
        if (focus) {
            await this.click({ withScroll: true });
        }
        for (const _act of (0, sat_utils_1.lengthToIndexesArray)(repeat)) {
            await this._driverElement.sendKeys(selenium_webdriver_1.Key.BACK_SPACE);
        }
    }
    /**
     * @example
     * const txt = '123';
     * const inpt = $('input');
     * await inpt.sendKeys(txt);
     * await inpt.pressEnter(true);
     *
     * @param {boolean} [focus] should element got focus event before execute enter
     *
     * @returns {Promise<void>}
     */
    async pressEnter(focus) {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "pressEnter" from wrapped API, args: `, focus);
        await this.getElement();
        if (focus) {
            await this.click({ withScroll: true });
        }
        await this._driverElement.sendKeys(selenium_webdriver_1.Key.ENTER);
    }
    // select specific
    async selectOption(optValue) {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "selectOption" from wrapped API, args: `, optValue);
        await this.getElement();
        // open options list
        await this.click({ withScroll: true });
        if ((0, sat_utils_1.isString)(optValue)) {
            return this.$$('option').each(async (opt) => {
                const text = await opt.getText();
                if (text.trim() === optValue.trim()) {
                    await opt.click();
                }
            });
        }
        if ((0, sat_utils_1.isObject)(optValue) && (0, sat_utils_1.safeHasOwnPropery)(optValue, 'value')) {
            return this.$$('option').each(async (opt) => {
                const text = await opt.getAttribute('value');
                if (text.trim() === optValue['value'].trim()) {
                    await opt.click();
                }
            });
        }
        if ((0, sat_utils_1.isObject)(optValue) && (0, sat_utils_1.safeHasOwnPropery)(optValue, 'label')) {
            return this.$$('option').each(async (opt) => {
                const text = await opt.getAttribute('label');
                if (text.trim() === optValue['label'].trim()) {
                    await opt.click();
                }
            });
        }
        if ((0, sat_utils_1.isObject)(optValue) && (0, sat_utils_1.safeHasOwnPropery)(optValue, 'index')) {
            return this.$$('option').each(async (opt) => {
                const text = await opt.getAttribute('index');
                if (text.trim() === optValue['index'].toString().trim()) {
                    await opt.click();
                }
            });
        }
    }
    /**
     * @example
     * const button = $('button')
     * const buttonIsPresent = await button.isPresent();
     *
     * @returns {Promise<boolean>} button is present
     */
    async isPresent() {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "isPresent" from wrapped API`);
        return this.getElement()
            .then(() => true)
            .catch((error) => {
            internals_1.promodLogger.engineLog(`Promod element interface gets error after method "isPresent" from wrapped API, error: `, error);
            return false;
        });
    }
    async callElementAction(action) {
        await this.getElement();
        return action();
    }
    async getId() {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "getId" from wrapped API`);
        await this.getElement();
        // @ts-ignore
        return this._driverElement.id_;
    }
    async getEngineElement() {
        internals_1.promodLogger.engineLog(`[SWD] Promod element interface calls method "getEngineElement" from wrapped API`);
        await this.getElement();
        return this._driverElement;
    }
    locator() {
        let locatorValue = '';
        if (this.parentSelector) {
            locatorValue += ` Parent: ${this.parentSelector} `;
        }
        return { value: `${locatorValue}${this.selector}` };
    }
    async isInteractionIntercepted(err) {
        const strErr = err.toString();
        return {
            isReadyToForce: (await this.isDisplayed()) &&
                (await this._driverElement.isEnabled()) &&
                strErr.includes('element click intercepted'),
        };
    }
}
exports.PromodSeleniumElement = PromodSeleniumElement;
function getInitElementRest(selector, root, ...rest) {
    let getParent = null;
    let getExecuteScriptArgs = null;
    /**
     * @info
     * in case if selector is string with "js=" marker or selector is a function
     */
    if (((0, sat_utils_1.isString)(selector) && selector.indexOf('js=') === 0) ||
        (0, sat_utils_1.isFunction)(selector) ||
        (0, sat_utils_1.isPromise)(selector)) {
        getExecuteScriptArgs = function getExecuteScriptArgs() {
            const localRest = rest.map((item) => (item && item.getEngineElement ? item.getEngineElement() : item));
            const rootPromiseIfRequired = root && root.getEngineElement ? root.getEngineElement() : root;
            if (rootPromiseIfRequired) {
                return [rootPromiseIfRequired, ...localRest];
            }
            return localRest;
        };
    }
    else if (root && root instanceof PromodSeleniumElement) {
        getParent = function getParent() {
            return root;
        };
    }
    return [getParent, getExecuteScriptArgs];
}
const $ = (selector, root, ...rest) => {
    const restArgs = getInitElementRest(selector, root, ...rest);
    internals_1.promodLogger.engineLog('Create new Promod element interface, args: ', ...restArgs);
    return new PromodSeleniumElement(selector, swd_client_1.browser, ...restArgs);
};
exports.$ = $;
function $$(selector, root, ...rest) {
    const restArgs = getInitElementRest(selector, root, ...rest);
    internals_1.promodLogger.engineLog('Create new Promod element interfaces, args: ', ...restArgs);
    return new PromodSeleniumElements(selector, swd_client_1.browser, ...restArgs);
}
exports.$$ = $$;
function preBindBrowserInstance(browserThaNeedsToBeBinded) {
    const $$ = (selector, root, ...rest) => {
        const restArgs = getInitElementRest(selector, root, ...rest);
        const collection = new PromodSeleniumElements(selector, browserThaNeedsToBeBinded, ...restArgs);
        return collection;
    };
    function $(selector, root, ...rest) {
        const restArgs = getInitElementRest(selector, root, ...rest);
        const element = new PromodSeleniumElement(selector, browserThaNeedsToBeBinded, ...restArgs);
        return element;
    }
    return {
        browser: browserThaNeedsToBeBinded,
        $$,
        $,
    };
}
exports.preBindBrowserInstance = preBindBrowserInstance;
//# sourceMappingURL=swd_element.js.map