"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncFilter = exports.asyncSome = exports.asyncEvery = exports.asyncReduce = exports.asyncForEach = exports.asyncMap = exports.asyncRepeat = void 0;
const types_1 = require("./types");
const utils_1 = require("./utils");
async function asyncRepeat(howMany, callBack, repeatEvenIfCallbackFails) {
    if (!(0, types_1.isNumber)(howMany)) {
        throw new TypeError(`asyncRepeat(): first argument should be a number, current arg is ${(0, types_1.getType)(howMany)}`);
    }
    if (!(0, types_1.isAsyncFunction)(callBack) && !(0, types_1.isFunction)(callBack)) {
        throw new TypeError(`asyncRepeat(): second argument should be a function or async function, current arg is ${(0, types_1.getType)(callBack)}`);
    }
    if (!(0, types_1.isUndefined)(repeatEvenIfCallbackFails) && !(0, types_1.isBoolean)(repeatEvenIfCallbackFails)) {
        throw new TypeError(`asyncRepeat(): third argument should be a boolean, current arg is ${(0, types_1.getType)(repeatEvenIfCallbackFails)}`);
    }
    for (const iterationNumber of (0, utils_1.lengthToIndexesArray)(howMany)) {
        if (repeatEvenIfCallbackFails) {
            try {
                await callBack(iterationNumber);
            }
            catch (_a) {
                /** ignore error */
            }
        }
        else {
            await callBack(iterationNumber);
        }
    }
}
exports.asyncRepeat = asyncRepeat;
async function asyncMap(ctxArray, callBack) {
    if (!(0, types_1.isArray)(ctxArray)) {
        throw new TypeError(`asyncMap(): first argument should be an array, current arg is ${(0, types_1.getType)(ctxArray)}`);
    }
    if (!(0, types_1.isAsyncFunction)(callBack) && !(0, types_1.isFunction)(callBack)) {
        throw new TypeError(`asyncMap(): second argument should be a function or async function, current arg is ${(0, types_1.getType)(callBack)}`);
    }
    const result = [];
    for (const [index, item] of ctxArray.entries()) {
        result.push(await Promise.resolve(callBack(item, index, ctxArray)));
    }
    return result;
}
exports.asyncMap = asyncMap;
async function asyncFilter(ctxArray, callBack) {
    if (!(0, types_1.isArray)(ctxArray)) {
        throw new TypeError(`asyncFilter(): first argument should be an array, current arg is ${(0, types_1.getType)(ctxArray)}`);
    }
    if (!(0, types_1.isAsyncFunction)(callBack) && !(0, types_1.isFunction)(callBack)) {
        throw new TypeError(`asyncFilter(): second argument should be a function or async function, current arg is ${(0, types_1.getType)(callBack)}`);
    }
    const result = [];
    for (const [index, item] of ctxArray.entries()) {
        const res = await Promise.resolve(callBack(item, index, ctxArray)).catch(() => false);
        if (res)
            result.push(item);
    }
    return result;
}
exports.asyncFilter = asyncFilter;
async function asyncEvery(ctxArray, callBack) {
    if (!(0, types_1.isArray)(ctxArray)) {
        throw new TypeError(`asyncEvery(): first argument should be an array, current arg is ${(0, types_1.getType)(ctxArray)}`);
    }
    if (!(0, types_1.isAsyncFunction)(callBack) && !(0, types_1.isFunction)(callBack)) {
        throw new TypeError(`asyncEvery(): second argument should be a function or async function, current arg is ${(0, types_1.getType)(callBack)}`);
    }
    for (const [index, item] of ctxArray.entries()) {
        const res = await Promise.resolve(callBack(item, index, ctxArray)).catch(() => false);
        if (!res)
            return false;
    }
    return true;
}
exports.asyncEvery = asyncEvery;
async function asyncSome(ctxArray, callBack) {
    if (!(0, types_1.isArray)(ctxArray)) {
        throw new TypeError(`asyncSome(): first argument should be an array, current arg is ${(0, types_1.getType)(ctxArray)}`);
    }
    if (!(0, types_1.isAsyncFunction)(callBack) && !(0, types_1.isFunction)(callBack)) {
        throw new TypeError(`asyncSome(): second argument should be a function or async function, current arg is ${(0, types_1.getType)(callBack)}`);
    }
    for (const [index, item] of ctxArray.entries()) {
        const res = await Promise.resolve(callBack(item, index, ctxArray)).catch(() => false);
        if (res)
            return true;
    }
    return false;
}
exports.asyncSome = asyncSome;
async function asyncReduce(ctxArray, callBack, ...rest) {
    if (!(0, types_1.isArray)(ctxArray)) {
        throw new TypeError(`asyncMap(): first argument should be an array, current arg is ${(0, types_1.getType)(ctxArray)}`);
    }
    if (!(0, types_1.isAsyncFunction)(callBack) && !(0, types_1.isFunction)(callBack)) {
        throw new TypeError(`asyncMap(): second argument should be a function or async function, current arg is ${(0, types_1.getType)(callBack)}`);
    }
    const [_first, ...restCtxArr] = ctxArray;
    let accumHolder = rest.length === 1 ? rest[0] : ctxArray[0];
    const executionArr = rest.length === 1 ? ctxArray : restCtxArr;
    const indexShift = rest.length === 1 ? 0 : 1;
    for (const [index, item] of executionArr.entries()) {
        // if accum does not exist we start from second item (first goes as an accum) so start index should be index + 1
        accumHolder = await Promise.resolve(callBack(accumHolder, item, index + indexShift, ctxArray));
    }
    return accumHolder;
}
exports.asyncReduce = asyncReduce;
async function asyncForEach(ctxArray, callBack) {
    if (!(0, types_1.isArray)(ctxArray)) {
        throw new TypeError(`asyncForEach(): first argument should be an array, current arg is ${(0, types_1.getType)(ctxArray)}`);
    }
    if (!(0, types_1.isAsyncFunction)(callBack) && !(0, types_1.isFunction)(callBack)) {
        throw new TypeError(`asyncForEach(): second argument should be a function or async function, current arg is ${(0, types_1.getType)(callBack)}`);
    }
    for (const [index, item] of ctxArray.entries()) {
        await callBack(item, index, ctxArray);
    }
}
exports.asyncForEach = asyncForEach;
//# sourceMappingURL=async.js.map