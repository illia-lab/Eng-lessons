"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareToPattern = void 0;
/* eslint-disable sonarjs/cognitive-complexity */
const types_1 = require("./types");
const utils_1 = require("./utils");
const result_handlers_1 = require("./compare/result.handlers");
function checkLengthIfRequired(expectedLength, actualLength) {
    if ((0, types_1.isUndefined)(expectedLength)) {
        return true;
    }
    const expectedLengthExpression = (0, types_1.isNumber)(expectedLength) ? `===${expectedLength}` : expectedLength;
    return (0, utils_1.execNumberExpression)(expectedLengthExpression, actualLength);
}
const compareToPattern = function (dataToCheck, pattern, options) {
    const _a = options || {}, { separator = '->', ignoreProperties, everyArrayItem = true, allowEmptyArray = true, patternIncludesMembers, customCheck, dataIncludesMembers, checkEmptyStrings, checkStringLength, dataIncldesPatternPart = false } = _a, primitivesOpts = __rest(_a, ["separator", "ignoreProperties", "everyArrayItem", "allowEmptyArray", "patternIncludesMembers", "customCheck", "dataIncludesMembers", "checkEmptyStrings", "checkStringLength", "dataIncldesPatternPart"]);
    const propertiesWhichWillBeIgnored = (0, utils_1.toArray)(ignoreProperties);
    let message = '';
    function compare(data, piece, arrayIndex) {
        if (message.length > 0 && !message.endsWith(' ')) {
            message += ' ';
        }
        function compareArrays(dataArray, patternArray) {
            if (!dataIncludesMembers &&
                !patternIncludesMembers &&
                !checkLengthIfRequired(patternArray.length, dataArray.length)) {
                message += `Message: expected length: ${patternArray.length}, actual lenght: ${dataArray.length}`;
                return false;
            }
            if (dataIncludesMembers && dataArray.lenght < patternArray.lenght) {
                message += `Message: data can not include all pattern member because of expected length: ${patternArray.length}, actual lenght: ${dataArray.length}`;
                return false;
            }
            if (patternIncludesMembers && dataArray.lenght > patternArray.lenght) {
                message += `Message: pattern can not include all pattern member because of expected length: ${patternArray.length}, actual lenght: ${dataArray.length}`;
                return false;
            }
            if (dataIncludesMembers) {
                const result = patternArray.every(patternArrayItem => dataArray.some(dataArrayItem => compare(dataArrayItem, patternArrayItem)));
                if (!result) {
                    message += 'Message: data does not include all pattern members';
                }
                return result;
            }
            if (patternIncludesMembers) {
                const result = dataArray.every(dataArrayItem => patternArray.some(patternArrayItem => compare(dataArrayItem, patternArrayItem)));
                if (!result) {
                    message += 'Message: pattern does not include all data members';
                }
                return result;
            }
            return dataArray.every((dataArrayItem, index) => compare(dataArrayItem, patternArray[index], index));
        }
        if ((0, types_1.isFunction)(piece) && customCheck) {
            const customCheckResult = piece(data);
            if (!customCheckResult) {
                message += `Message: expected that custom check result should be true`;
            }
            return customCheckResult;
        }
        if ((0, types_1.isPrimitive)(data) &&
            ((0, types_1.isPrimitive)(piece) ||
                (0, types_1.isRegExp)(piece) ||
                (checkStringLength && (0, utils_1.safeHasOwnPropery)(piece, 'length') && Object.keys(piece).length === 1))) {
            const { comparisonMessage, comparisonResult } = (0, result_handlers_1.comparePrimitives)(data, piece, Object.assign({ checkEmptyStrings,
                checkStringLength }, primitivesOpts));
            if (!comparisonResult) {
                const indexMessage = (0, types_1.isNumber)(arrayIndex) ? `[${arrayIndex}]` : '';
                message += `${indexMessage}Message: ${comparisonMessage}`;
            }
            return comparisonResult;
        }
        if (propertiesWhichWillBeIgnored.length && (0, types_1.isObject)(piece)) {
            piece = Object.keys(piece)
                .filter(key => !propertiesWhichWillBeIgnored.includes(key))
                .reduce((requiredKeys, key) => {
                requiredKeys[key] = piece[key];
                return requiredKeys;
            }, {});
        }
        if (((0, types_1.isEmptyObject)(piece) || (0, types_1.isUndefined)(piece) || (0, types_1.isNull)(piece)) && checkEmptyStrings && (0, types_1.isObject)(data)) {
            return Object.keys(data).every(key => {
                const compareResult = compare(data[key]);
                if (!compareResult) {
                    const indexMessage = (0, types_1.isNumber)(arrayIndex) ? `${key}[${arrayIndex}]` : `${key}`;
                    message += ` message key: ${indexMessage}`;
                }
                return compareResult;
            });
        }
        if (((0, types_1.isEmptyObject)(piece) || (0, types_1.isUndefined)(piece) || (0, types_1.isNull)(piece)) && checkEmptyStrings && (0, types_1.isArray)(data)) {
            return data.every((dataItem, index) => {
                return compare(dataItem, undefined, index);
            });
        }
        if ((0, types_1.isObject)(piece) && (0, types_1.isObject)(data)) {
            const call = dataIncldesPatternPart ? 'some' : 'every';
            return Object.keys(piece)[call](key => {
                const compareResult = compare(data[key], piece[key]);
                if (!compareResult) {
                    const indexMessage = (0, types_1.isNumber)(arrayIndex) ? `${key}[${arrayIndex}]` : `${key}`;
                    message += ` message key: ${indexMessage}`;
                }
                return compareResult;
            });
        }
        if ((0, types_1.isArray)(data) && (0, types_1.isArray)(piece)) {
            return compareArrays(data, piece);
        }
        if ((0, types_1.isArray)(data) && (0, types_1.isObject)(piece)) {
            const { length, toCount, ignoreIndexes, toCompare } = piece, checkDataPiece = __rest(piece, ["length", "toCount", "ignoreIndexes", "toCompare"]);
            const lengthToCheck = (0, utils_1.safeHasOwnPropery)(piece, 'length') ? length : allowEmptyArray ? undefined : '>0';
            if ((0, types_1.isEmptyObject)(checkDataPiece) &&
                checkLengthIfRequired(lengthToCheck, data.length) &&
                !(0, utils_1.safeHasOwnPropery)(piece, 'toCompare')) {
                return true;
            }
            if (checkLengthIfRequired(lengthToCheck, data.length)) {
                const dataWithoutIndexesThatShouldBeIgnored = data.filter((_dataItem, index) => {
                    if ((0, types_1.isNumber)(ignoreIndexes) || (0, types_1.isArray)(ignoreIndexes)) {
                        const ignore = (0, utils_1.toArray)(ignoreIndexes);
                        return !ignore.includes(index);
                    }
                    return true;
                });
                if ((0, types_1.isArray)(toCompare)) {
                    return compareArrays(dataWithoutIndexesThatShouldBeIgnored, toCompare);
                }
                const result = dataWithoutIndexesThatShouldBeIgnored.filter((dataItem, index) => {
                    if ((0, types_1.isPrimitive)(toCompare) && (0, utils_1.safeHasOwnPropery)(piece, 'toCompare')) {
                        return compare(dataItem, toCompare, index);
                    }
                    return compare(dataItem, checkDataPiece, index);
                });
                if ((0, types_1.isNumber)(toCount)) {
                    return toCount === result.length;
                }
                return everyArrayItem ? result.length === dataWithoutIndexesThatShouldBeIgnored.length : result.length;
            }
            else {
                message += `Message: expected length: ${lengthToCheck}, actual lenght: ${data.length}`;
                return false;
            }
        }
        if ((0, types_1.getType)(data) !== (0, types_1.getType)(piece)) {
            message += `Message: seems like types are not comparable, expected: ${(0, types_1.getType)(piece)}, actual: ${(0, types_1.getType)(data)}`;
        }
        return false;
    }
    const result = compare(dataToCheck, pattern);
    if (result) {
        message = '';
        // clean up message
    }
    else {
        // TODO message formatting should be improved
        const indexPattern = /(\[\d])/;
        function createMessage(notFormattedMessage) {
            return notFormattedMessage
                .replaceAll(/  /gi, ' ')
                .split(' message key: ')
                .reverse()
                .reduce((acc, item, index, arr) => {
                if (index === 0 && arr.length - 1 !== index) {
                    acc += `${item}${separator}`;
                }
                else if (indexPattern.test(item)) {
                    const prevIndex = item.match(indexPattern)[0];
                    const key = item.replace(indexPattern, '');
                    const isSeparator = arr.length - 1 === index ? '' : separator;
                    acc = acc.replace(new RegExp(`(${separator})$`), `${prevIndex}${separator}${key}${isSeparator}`);
                }
                else if (arr.length - 1 === index) {
                    acc += `${item}`;
                }
                else {
                    acc += `${item}${separator}`;
                }
                return acc;
            }, '')
                .trim();
        }
        message =
            message.split(' message key: ').length > 2 &&
                message
                    .split('Message:')
                    .map(m => m.trim())
                    .filter(m => !indexPattern.test(m))
                    .filter(Boolean).length > 1
                ? message
                    .split('Message:')
                    .map(m => m.trim())
                    .filter(Boolean)
                    .map(m => createMessage(`Message: ${m}`))
                    .join('\n')
                : createMessage(message);
    }
    return { result, message };
};
exports.compareToPattern = compareToPattern;
compareToPattern.toDataIncludes = result_handlers_1.toDataIncludes;
compareToPattern.checkThatDataIncludes = result_handlers_1.checkThatDataIncludes;
compareToPattern.removeDataIncludesId = result_handlers_1.removeDataIncludesId;
compareToPattern.toPatternIncludes = result_handlers_1.toPatternIncludes;
compareToPattern.checkThatPatternIncludes = result_handlers_1.checkThatPatternIncludes;
compareToPattern.removePatternIncludesId = result_handlers_1.removePatternIncludesId;
compareToPattern.toCheckNumber = result_handlers_1.toCheckNumber;
compareToPattern.checkThatCheckNumber = result_handlers_1.checkThatCheckNumber;
compareToPattern.removeCheckNumberId = result_handlers_1.removeCheckNumberId;
compareToPattern.dataToLowercase = result_handlers_1.dataToLowercase;
compareToPattern.checkThatDataLowercase = result_handlers_1.checkThatDataLowercase;
compareToPattern.removeDataLowercase = result_handlers_1.removeDataLowercase;
compareToPattern.patternToLowercase = result_handlers_1.patternToLowercase;
compareToPattern.checkThatPatternLowercase = result_handlers_1.checkThatPatternLowercase;
compareToPattern.removePatternLowercase = result_handlers_1.removePatternLowercase;
compareToPattern.dataToUppercase = result_handlers_1.dataToUppercase;
compareToPattern.checkThatDataUppercase = result_handlers_1.checkThatDataUppercase;
compareToPattern.removeDataUppercase = result_handlers_1.removeDataUppercase;
compareToPattern.patternToUppercase = result_handlers_1.patternToUppercase;
compareToPattern.checkThatPatternUppercase = result_handlers_1.checkThatPatternUppercase;
compareToPattern.removePatternUppercase = result_handlers_1.removePatternUppercase;
//# sourceMappingURL=compare.js.map