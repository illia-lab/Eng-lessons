"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNotEmptyObject = exports.isNotEmptyArray = exports.isEmptyObject = exports.isEmptyArray = exports.canBeProxed = exports.isPrimitive = exports.getType = exports.isType = exports.typesEnum = exports.isArguments = exports.isBuffer = exports.isDate = exports.isAsyncFunction = exports.isRegExp = exports.isFunction = exports.isSymbol = exports.isBoolean = exports.isPromise = exports.isNumber = exports.isUndefined = exports.isMap = exports.isSet = exports.isString = exports.isNull = exports.isObject = exports.isArray = void 0;
const typesEnum = {
    object: '[object Object]',
    array: '[object Array]',
    set: '[object Set]',
    map: '[object Map]',
    function: '[object Function]',
    asyncFunction: '[object AsyncFunction]',
    promise: '[object Promise]',
    regExp: '[object RegExp]',
    null: '[object Null]',
    string: '[object String]',
    undefined: '[object Undefined]',
    symbol: '[object Symbol]',
    number: '[object Number]',
    boolean: '[object Boolean]',
    arguments: '[object Arguments]',
    buffer: '[object Uint8Array]',
};
exports.typesEnum = typesEnum;
const pritiveTypes = [
    '[object Null]',
    'null',
    '[object String]',
    'string',
    '[object Undefined]',
    'undefined',
    '[object Number]',
    'number',
    '[object Boolean]',
    'boolean',
    '[object Symbol]',
    'symbol',
];
const typesReverseEnum = {
    '[object Object]': 'object',
    '[object Array]': 'array',
    '[object Set]': 'set',
    '[object Function]': 'function',
    '[object AsyncFunction]': 'asyncFunction',
    '[object Promise]': 'promise',
    '[object Map]': 'map',
    '[object RegExp]': 'regExp',
    '[object Symbol]': 'symbol',
    '[object Null]': 'null',
    '[object String]': 'string',
    '[object Undefined]': 'undefined',
    '[object Number]': 'number',
    '[object Boolean]': 'boolean',
};
function isPrimitive(arg) {
    return pritiveTypes.includes(Object.prototype.toString.call(arg));
}
exports.isPrimitive = isPrimitive;
function getType(arg) {
    return typesReverseEnum[Object.prototype.toString.call(arg)];
}
exports.getType = getType;
function isObject(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.object;
}
exports.isObject = isObject;
function isArray(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.array;
}
exports.isArray = isArray;
function isNull(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.null;
}
exports.isNull = isNull;
function isString(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.string;
}
exports.isString = isString;
function isUndefined(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.undefined;
}
exports.isUndefined = isUndefined;
function isSet(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.set;
}
exports.isSet = isSet;
function isMap(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.map;
}
exports.isMap = isMap;
function isSymbol(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.symbol;
}
exports.isSymbol = isSymbol;
function isNumber(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.number && !Number.isNaN(arg);
}
exports.isNumber = isNumber;
function isBoolean(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.boolean;
}
exports.isBoolean = isBoolean;
function isBuffer(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.buffer;
}
exports.isBuffer = isBuffer;
function isFunction(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.function;
}
exports.isFunction = isFunction;
function isAsyncFunction(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.asyncFunction;
}
exports.isAsyncFunction = isAsyncFunction;
function isPromise(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.promise;
}
exports.isPromise = isPromise;
function isRegExp(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.regExp;
}
exports.isRegExp = isRegExp;
function isDate(arg) {
    return arg instanceof Date;
}
exports.isDate = isDate;
function isArguments(arg) {
    return Object.prototype.toString.call(arg) === typesEnum.arguments;
}
exports.isArguments = isArguments;
function isType(arg, typeArg) {
    return Object.prototype.toString.call(arg) === typesEnum[typeArg];
}
exports.isType = isType;
function canBeProxed(arg) {
    try {
        new Proxy(arg, {});
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.canBeProxed = canBeProxed;
function isEmptyArray(arg) {
    return isArray(arg) && !arg.length;
}
exports.isEmptyArray = isEmptyArray;
function isNotEmptyArray(arg) {
    return isArray(arg) && !!arg.length;
}
exports.isNotEmptyArray = isNotEmptyArray;
function isEmptyObject(arg) {
    return isObject(arg) && !Object.keys(arg).length;
}
exports.isEmptyObject = isEmptyObject;
function isNotEmptyObject(arg) {
    return isObject(arg) && !!Object.keys(arg).length;
}
exports.isNotEmptyObject = isNotEmptyObject;
//# sourceMappingURL=types.js.map